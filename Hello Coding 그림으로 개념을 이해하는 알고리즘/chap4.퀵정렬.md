## Chap3. 퀵 정렬

### 01 분할 정복(divide-and-conquer)

분할 정복 전략은 재귀적 알고리즘이다. 문제를 분할 정복 전략으로 풀기 위해서는 다음 두 가지 단계를 거친다.

1. 기본 단게를 해결한다. 이 부분은 가능한 한 간단한 문제여야 한다.
2. 문제가 기본 단계가 될 때까지 나누거나 작게 만든다.

**cf.) 유클리드 알고리즘(유클리드 호제법)**

유클리드 호제법은 2개의 자연수 또는 정식의 최대공약수를 구하는 알고리즘의 하나이다. 호제법이란 두 수가 서로 상대방 수를 나누어 결국 원하는 수를 얻는 알고리즘을 나타낸다. 알고리즘의 과정은 다음과 같다. 2개의 자연수(또는 정식) a, b에 대해서 a>b일 때, a를 b로 나눈 나머지를 r이라 하면 a와 b의 최대공약수는 b와 r의 최대공약수와 같다. 이러한 특성에 따라 b를 r로 나눈 너머지 r'를 구하고 다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.

cf.) 함수형 프로그래밍

함수형 프로그래밍 언어에는 반복문이 없다. 따라서 무조건 재귀 함수를 사용해야하는 경우가 존재한다. 

### 02 퀵 정렬

퀵 정렬은 선택 정렬보다 훨씬 빠르고 유용하게 사용되는 정렬 알고리즘이다. C언어 표준 라이브러리의 qsort()가 퀵 정렬을 구현한 함수이다. 

- 퀵 정렬 수행 단계

리스트 안에 있는 한 요소를 선택하고, 이 요소를 피벗(pivot)이라고 한다.

1. 분할(Divide) : 입력 리스트를 피벗을 기준으로 비균등하게 2개의 하위 배열로 분할한다.
2. 정복(Conquer) : 하위 배열에 대해 재귀적으로 퀵 정렬을 호출한다.
3. 결합 : 정렬된 하위 배열들을 하나의 배열에 합병한다.



cf.) 귀납적 증명

귀잡법은 특별한 특징의 제한적 관찰을 통해 유형의 공통된 성질 또는 관계를 이끌어 내거나, 반복되는 현상의 패턴들의 제한적 관찰을 통해 법칙을 형식화하는 것이다. 귀납적 증명에도 기본 단계와 귀납 단계가 필요하다.

```python
def quicksort(arr):
  if len(arr) < 2:
    return arr
  pivot = arr[0] # 피벗 원소를 리스트의 첫번째 원소로 지정.
  less = [i for i in array[1:] if i <= pivot]
  greater = [i for i in array[1:] if i > pivot]
  return quicksort(less) + [pivot] + quicksort(greater)
```

### 03 빅오 표기법 복습

- 일반적인 빅오 실행 시간 유형

이진 탐색 : O(log n) < 단순 탐색 : O(n) <퀵 정렬 : O(n log n) < 선택 정렬 : O(n^2) < 외판원 문제 : O(n!)

퀵 정렬의 경우 평균적인 경우에 O(n log n) 실행 시간을 가지며, 최악의 경우에는 O(n^2)이 될 수도 있다.

- 병합 정렬과 퀵 정렬 비교

병합 정렬의 실행 시간은 O(n log n)이다. 퀵 정렬의 최악의 경우 O(n^2)이 될 수도 있기 때문에 병합 정렬이 더욱 유용해 보일 수 있다.

``` python
def print_items(arr):
  for item in arr:
    print(item)
```

```python
from time import sleep
def print_items2(arr):
  for item in arr:
    sleep(1)
    print(item)
```

빅오 표기법으로 두 함수는 모두 O(n)의 실행 시간을 가지지만 실제로는 print_items()가 더 빠르다. 왜냐하면 O(n) = c*n(c : 알고리즘이 소비하는 어떤 특정한 상수 시간)이므로 빅오 표기법은 같지만 c에 따라 실행 시간의 대소 비교가 가능하다.

만약 두 개의 알고리즘이 서로 다른 빅오 표기법의 시간을 가진다면 상수 c는 크게 문제가 되지 않기 때문에 보통 상수를 무시한다. 하지만 **가끔은 상수 때문에 차이가 발생하기도 한다.** 병합 정렬과 퀵 정렬이 그 예이다. **퀵 정렬이 병합 정렬보다 더 작은 상수를 가지므로 실행 시간이 O(n log n)으로 동일할 경우 퀵 정렬이 더 빠르다.** 그리고 퀵 정렬을 사용할 때 최악의 경우보다 일반적인 경우가 훨씬 많이 발생한다.

- 평균적인 경우와 최악의 경우 비교

퀵 정렬의 성능은 선택한 피벗 원소에 크게 의존하여 달라진다. 주어진 리스트를 반으로 나누는 피벗 원소를 선택하면 재귀적 호출의 수를 줄일 수 있다. 

만약 항상 첫 번째 원소를 피벗 원소로 선택하면 호출 스택의 높이가 n이고, 정 가운데 있는 원소를 피벗 원소로 선택하면 호출 스택의 높이가 log n이 된다. 그리고 매 단계에서 리스트의 n개 원소 모두를 피벗 원소와 비교해야한다.

따라서 최악의 경우에는 O(n) * O(n) = O(n^2), 최선의 경우에는 O(n) * O(log n) = O(n log n)이 걸린다. 



[유클리드 알고리즘 참조 링크]:http://lonpeach.com/2017/11/12/Euclidean-algorithm/(http://lonpeach.com/2017/11/12/Euclidean-algorithm/)